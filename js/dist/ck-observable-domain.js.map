{"version":3,"sources":["webpack://ckObservableDomain/webpack/universalModuleDefinition","webpack://ckObservableDomain/webpack/bootstrap","webpack://ckObservableDomain/./src/index.ts","webpack://ckObservableDomain/./node_modules/@signature/json-graph-serializer/src/index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","json_graph_serializer_1","ObservableDomain","initialState","_this","deserialize","prefix","_props","P","_tranNum","N","g","count","len","length","o_1","v","undefined","graph","countAndLiftContainers","O","_objCount","_graph","_roots","R","map","g_1","_i","_a","sent","all","applyEvent","event","Error","events","E","e","newOne","Map","Set","push","getValue","a","idx","splice","Array","clear","delete","ref","serialize","options","substitor","assign","rR","rI","rT","marker","cleanup","markObj","JSON","stringify","k","[object Object]","Number","markNum","sv","String","markTyp","forEach","activator","extRef","rev","type","add","parse","processA","has","set","__webpack_exports__"],"mappings":"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","file":"ck-observable-domain.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ckObservableDomain\"] = factory();\n\telse\n\t\troot[\"ckObservableDomain\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* tslint:disable */\r\nimport { deserialize } from \"@signature/json-graph-serializer\";\r\n\r\nexport interface ObservableDomainEvent {\r\n    N: number;\r\n    E: any[];\r\n}\r\n\r\nexport interface ObservableDomainState {\r\n    N: number;\r\n    P: string[];\r\n    O: any;\r\n    R: number[];\r\n}\r\n\r\nexport class ObservableDomain {\r\n    private readonly _props: string[];\r\n    private _tranNum: number;\r\n    private _objCount: number;\r\n    private readonly _graph: any[];\r\n    private readonly  _roots: any[];        \r\n\r\n    constructor(initialState: string | ObservableDomainState) {\r\n        const o : ObservableDomainState = typeof (initialState) === \"string\"\r\n                                            ? deserialize(initialState, { prefix: \"\" })\r\n                                            : initialState;\r\n        this._props = o.P;\r\n        this._tranNum = o.N;\r\n        const r = countAndLiftContainers(o.O);\r\n        this._objCount = r.count;\r\n        this._graph = r.graph;\r\n        this._roots = o.R.map(i => this._graph[i]);\r\n\r\n        function countAndLiftContainers(g: any[]) {\r\n            let count = 0;\r\n            const len = g.length;\r\n            for (let i = 0; i < len; ++i) {\r\n                const o = g[i];\r\n                if (o != null ) {\r\n                    ++count;\r\n                    if( typeof o === \"object\") {\r\n                        for (let p in o) {\r\n                            const v = o[p];\r\n                            if (v && typeof v === \"object\") {\r\n                                const c = v[\"$C\"];\r\n                                if (c !== undefined) {\r\n                                    o[p] = g[v[\"$i\"]];\r\n                                }\r\n                            }\r\n                        }\r\n                    }   \r\n                }\r\n            }\r\n            return {count:count,graph:g};\r\n        }\r\n    }\r\n\r\n    public get transactionNumber() : number { \r\n        return this._tranNum;\r\n    }\r\n\r\n    public get allObjectsCount() : number { \r\n        return this._objCount;\r\n    }\r\n\r\n    public get allObjects() : Iterable<any>  { \r\n        function* all(g:any[])\r\n        {\r\n            for( const o of g )\r\n            {\r\n                if( o !== null ) yield o;\r\n            }\r\n        }\r\n        return all( this._graph );\r\n     }\r\n\r\n    public get roots() : ReadonlyArray<any> { \r\n        return this._roots;\r\n    }\r\n\r\n    public applyEvent(event: ObservableDomainEvent) {\r\n        if (this._tranNum + 1 !== event.N) {\r\n            throw new Error(`Invalid transaction number. Expected: ${this._tranNum + 1}, got ${event.N}.`);\r\n        }\r\n\r\n        const events = event.E;\r\n        for (let i = 0; i < events.length; ++i) {\r\n            const e = events[i];\r\n            const code: string = e[0];\r\n            switch (code) {\r\n                case \"N\": // NewObject\r\n                    {\r\n                        let newOne;\r\n                        switch (e[2]) {\r\n                            case \"\": newOne = {}; break;\r\n                            case \"A\": newOne = []; break;\r\n                            case \"M\": newOne = new Map(); break;\r\n                            case \"S\": newOne = new Set(); break;\r\n                            default: throw new Error(`Unexpected Object type; ${e[2]}. Must be A, M, S or empty string.`);\r\n                        }\r\n                        this._graph[e[1]] = newOne;\r\n                        this._objCount++;\r\n                        break;\r\n                    }\r\n                case \"D\": // DisposedObject\r\n                    {\r\n                        this._graph[e[1]] = null;\r\n                        this._objCount--;\r\n                        break;\r\n                    }\r\n                case \"P\": // NewProperty\r\n                    {\r\n                        if (e[2] != this._props.length) {\r\n                            throw new Error(`Invalid property creation event for '${e[1]}': index must be ${this._props.length}, got ${e[2]}.`);\r\n                        }\r\n                        this._props.push(e[1]);\r\n                        break;\r\n                    }\r\n                case \"C\":  // PropertyChanged\r\n                    {\r\n                        this._graph[e[1]][this._props[<any>e[2]]] = this.getValue(e[3]);\r\n                        break;\r\n                    }\r\n                case \"I\":  // ListInsert\r\n                    {\r\n                        const a = this._graph[e[1]];\r\n                        const idx = e[2];\r\n                        const v = this.getValue(e[3]);\r\n                        if (idx === a.length) a[idx] = v;\r\n                        else a.splice(idx, 0, v);\r\n                        break;\r\n                    }\r\n                case \"CL\": // CollectionClear\r\n                    {\r\n                        const c = this._graph[e[1]];\r\n                        if (c instanceof Array) c.length = 0;\r\n                        else c.clear();\r\n                        break;\r\n                    }\r\n                case \"R\":  // ListRemoveAt\r\n                    {\r\n                        this._graph[e[1]].splice(e[2], 1);\r\n                        break;\r\n                    }\r\n                case \"S\":  // ListSetAt\r\n                    {\r\n                        this._graph[e[1]].splice(e[2], 1, this.getValue(e[3]));\r\n                        break;\r\n                    }\r\n                case \"K\":   // CollectionRemoveKey\r\n                    {\r\n                        this._graph[e[1]].delete(this.getValue(e[2]));\r\n                        break;\r\n                    }\r\n                default: throw new Error(`Unexpected Event code: '${e[0]}'.`);\r\n            }\r\n        }\r\n        this._tranNum = event.N;\r\n    }\r\n\r\n    private getValue(o: any) {\r\n        if (o != null) {\r\n            var ref = o[\">\"];\r\n            if (ref !== undefined) return this._graph[ref];\r\n        }\r\n        return o;\r\n    }\r\n}\r\n\r\n\r\n\r\n","/**\r\n * Serializes an object in JSON that can contain internal relationships.\r\n * Serialized objects contain a \"<prefix>i\" field that is the index\r\n * in the breadth-first traversal of the graph done by JSON.stringify().\r\n * References to already serialized objects are exposed as single-property\r\n * objects like { \"<prefix>r\": idx }.\r\n * The deserialize function uses the index to restore the complete graph.\r\n * Parameter prefix is optional. It defaults to \"~$£€\".\r\n * @param {object} o - The object to serialize\r\n * @param {object} options - Serialization options: prefix (default '~$£€'), substitor\r\n * @return {string} The serialized value.\r\n */\r\nexport function serialize(o, options) {\r\n    const { prefix, substitor } = Object.assign({ prefix: \"~$£€\" }, options);\r\n    const rR = prefix + \">\";\r\n    const rI = prefix + \"°\";\r\n    const rT = prefix + \"þ\";\r\n    const marker = Symbol();\r\n    let cleanup = [];\r\n    try {\r\n        let c = 0;\r\n        function markObj(o) { o[marker] = 1; return o; }\r\n        function markNum(n) { return markObj(new Number(n)); }\r\n        function markTyp(s) {\r\n            if (typeof s !== \"string\") throw new Error(\"Type must be a String.\");\r\n            return markObj(new String(s));\r\n        }\r\n        return JSON.stringify(o, function (k, v) {\r\n            if (k === rR || k === rI || k === rT) {\r\n                if (v !== null && v[marker]) return v;\r\n                throw new Error(\"Conflicting serialization prefix: property '\" + k + \"' exists.\");\r\n            }\r\n            if (v === null || typeof v !== \"object\" || v[marker]) return v;\r\n            let ref = v[rI];\r\n            if (ref) {\r\n                if (ref[marker]) return { [rR]: ref };\r\n                throw new Error(\"Conflicting serialization prefix: property '\" + rI + \"' exists.\");\r\n            }\r\n            v[rI] = ref = markNum(c++);\r\n            cleanup.push(v);\r\n            if (v instanceof Array) {\r\n                v = markObj([markObj({ [rT]: markObj([ref, \"A\"]) }), ...v]);\r\n            }\r\n            else if (v instanceof Map) {\r\n                v = markObj([markObj({ [rT]: markObj([ref, \"M\"]) }), ...[...v].map(e => markObj(e))]);\r\n            }\r\n            else if (v instanceof Set) {\r\n                v = markObj([markObj({ [rT]: markObj([ref, \"S\"]) }), ...v]);\r\n            }\r\n            else if (substitor) {\r\n                let sv = substitor(v, rT);\r\n                if (sv && sv !== v) {\r\n                    v = sv;\r\n                    v[rI] = ref;\r\n                    v[rT] = markTyp(v[rT] || \"\");\r\n                }\r\n            }\r\n            return v;\r\n        });\r\n    }\r\n    finally {\r\n        cleanup.forEach(o => delete o[rI]);\r\n    }\r\n};\r\n\r\n/**\r\n * Deserializes a previously-serialized object graph.\r\n * Parameter prefix is optional and defaults to \"~$£€\": it must, of course,\r\n * be the same as the prefix used to serialize the graph.\r\n * @param {(string|object)} o - The serialized string, or parsed object.\r\n * @param {object} options - Serialization options: prefix (default '~$£€'), activator\r\n * @return {object} The deserialized value.\r\n */\r\nexport function deserialize(s /*:string|object*/, options) {\r\n    const { prefix, activator } = Object.assign({ prefix: \"~$£€\" }, options);\r\n    const rR = prefix + \">\";\r\n    const rI = prefix + \"°\";\r\n    const rT = prefix + \"þ\";\r\n    let extRef = null;\r\n    const map = [];\r\n\r\n    function rev(k, v) {\r\n        let type = null;\r\n        if (v instanceof Array) {\r\n            if (v.length > 0\r\n                && v[0] != null\r\n                && (type = v[0][rT]) !== undefined) {\r\n                v.splice(0, 1);\r\n                switch (type[1]) {\r\n                    case \"A\": break;\r\n                    case \"M\": v = Object.assign(new Map(), { \"v\": v }); break;\r\n                    case \"S\": v = Object.assign(new Set(), { \"v\": v }); break;\r\n                    default: throw new Error(\"Expecting typed array to be 'A', 'M' or 'S'.\");\r\n                }\r\n                map[type[0]] = v;\r\n            }\r\n        }\r\n        else if (v !== null) {\r\n            const idx = v[rI];\r\n            if (idx !== undefined) {\r\n                delete v[rI];\r\n                if ((type = v[rT]) !== undefined) {\r\n                    delete v[rT];\r\n                    if (activator) {\r\n                        v = activator(v, type);\r\n                        if (v) {\r\n                            if (extRef === null) extRef = new Set();\r\n                            extRef.add(v);\r\n                        }\r\n                    }\r\n                }\r\n                map[idx] = v;\r\n            }\r\n        }\r\n        return v;\r\n    }\r\n\r\n    // This simple depth-first traversal applies the reviver to an already \r\n    // JSON parsed tree.\r\n    function d(o) {\r\n        if (o) {\r\n            if (o instanceof Array) {\r\n                for (let i = 0; i < o.length; ++i) {\r\n                    const v = o[i];\r\n                    d(v);\r\n                    o[i] = rev(i, v);\r\n                }\r\n            }\r\n            else if (typeof (o) === \"object\") {\r\n                for (const p in o) {\r\n                    const v = o[p];\r\n                    d(v);\r\n                    o[p] = rev(p, v);\r\n                }\r\n            }\r\n        }\r\n        return o;\r\n    }\r\n    // If its a string, JSON.parse and the reviver handle the first step: registering the \r\n    // objects in map array and any external references into extRef set.   \r\n    const o = typeof (s) === \"string\"\r\n        ? JSON.parse(s, rev)\r\n        : rev(undefined, d(s));\r\n\r\n    // Second step is to handles the collections (array, map and set).\r\n    function processA(map, a) {\r\n        const len = a.length;\r\n        for (let i = 0; i < len; ++i) {\r\n            const c = a[i];\r\n            if (c) {\r\n                const ref = c[rR];\r\n                if (ref !== undefined) a[i] = map[ref];\r\n            }\r\n        }\r\n    }\r\n    for (let i of map) {\r\n        if (extRef === null || !extRef.has(i)) {\r\n            if (i instanceof Array) {\r\n                processA(map, i);\r\n            }\r\n            else if (i instanceof Map) {\r\n                i.v.forEach(e => processA(map, e));\r\n                i.v.forEach(e => i.set(e[0], e[1]));\r\n                delete i.v;\r\n            }\r\n            else if (i instanceof Set) {\r\n                processA(map, i.v);\r\n                i.v.forEach(e => i.add(e));\r\n                delete i.v;\r\n            }\r\n            else {\r\n                for (const p in i) {\r\n                    const o = i[p];\r\n                    if (o !== null) {\r\n                        const ref = o[rR];\r\n                        if (ref !== undefined) i[p] = map[ref];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return o;\r\n}"],"sourceRoot":""}